--------------------------------------- КОНЦЕПЦИЯ ---------------------------------------

Хранение матрицы в формате CSR:
 	В составе класса 3 динамических массива:
 	- data - массив значений. Хранит значения ненулевых элементов, взятые подряд из 
 	первой непустой строки, затем идут значения из следующей непустой строки и т.д.;
 	- col - массив индексов столбцов. Размер равен размеру массива data, хранит 
 	номера столбцов, соответствующих элементов из массива значений.
 	- row массив индексации строк - массив размера n + 1, где n - кол-во строк в 
 	матрице. Для индекса i хранит количество ненулевых элементов в строках до i − 1 
 	включительно. Последний элемент массива индексации строк совпадает с кол-вом 
 	ненулевых элементов (размером массива data и col) а первый всегда равен 0.
 	
 	Для того, чтобы посмотреть содержимое matrix[i][j] (индексация с 0), нужно:
 	0. Если row[i+1] - row[i] = 0, то в строке нет ненулевых элементов.
 	1. row[i] - индекс первого ненулевого элемента i-й строки в масиве data. То есть
 	matrix[i][col[row[i]]]- первый ненулевой элемент iй строки, а data[row[i]] - его
 	значение.
 	2. Итак, в i-й строке всего row[i+1] - row[i] ненулевых элементов. Смотрим
 	содержимое массива col и ищем значение j. Если в диапазоне от col[row[i]] до 
 	col[row[i+1]] такого значения нет, то matrix[i][j] = 0, иначе 
 	matrix[i][j] = data[k], где k: col[k] = j и row[i] <= k < row[i+1]
 	
 	Примеры:
		data {1, 2, 3, 4, 5}       |1      |
		col {0, 0, 2, 1, 3}        |2   3  |
		row {0, 1, 3, 5}           |  4   5|
		
		data {1, 6!, 2, 3, 4, 5}   |1   6  |
		col {0, 2!, 0, 2, 1, 3}    |2   3  |
		row {0, 1+1, 3+1, 5+1}     |  4   5|
		
		data {1, 2, 6!, 3, 4, 5}   |1   6  |
		col {0, 0, 1!, 2, 1, 3}    |2 6 3  |
		row {0, 1, 3+1, 5+1}       |  4   5|

		The number of elements in a column №r equals row[r] - row[r-1]
		
	В составе класса также есть 2 подкласса Row и constRow, которые, в свою очередь,
	имеют свои подклассы suRow и constsubRow. Данные классы используются для 
	перегрузки операторов разыменования и индексации.

------------------------------------ ОПИСАНИЕ КЛАССА ------------------------------------

1. int num_columns; // кол-во столбцов в матрице
2. int num_rows;    // кол-во строк в матрице
3. double *data;    // массив значений, динамический
4. int *row;        // массив индексации строк, динамический
5. int *col;        // массив индексации столбцов
6. int non_zero;    // размер динамических массивов data и col

------------------------------------ ОПИСАНИЕ МЕТОДОВ -----------------------------------

1. Конструктор.
 	При создании матрица инициализирована нулями. Начальная длина динамических 
 	массивов (rows*columns + 10) / 5. По умолчанию количество строк и столбцов равно 
 	константному числу N.
 	
 2. Метод double* GetElem(int r, int c) 
  	Метод получает на вход строку и столбец искомого элемента, при его отсутсвии 
  	создает ячейку в массиве data и col, и возвращает адрес ячейки в массиве data.
  	Алгоритм:
  	1. Look for a col[i] == c in range from row[r] to row[r+1] - 1
	2. If there is nothing and i == row[r+1], shift everything right
	3. If col[i-1] < c < col[i], shift everythinf right 
	4. return pointer to the element in data array 
	
3. Метод void SparseMatrix::CleanZero()
	Метод убирает нулевые значения (точнее значения по модулю меньшие эпсилон) из
	массива значений data, сдвигает остальные элементы массива влева. Аналогичым
	образом меняется массив col. В массиве row нужные элементы уменьшаются на 0.
	Ситуация возникновения нулей в массиве может быть обусловлена выражениями типа:
	A[i][j] = 0;
	*(*(A + i) + j) = 0;
	т.к. операция присваивания не перегружена, и пользователь можнт по ошибке 
	добавить в матрицу ноль.

4. Геттеры и сеттеры
	double get(size_t, size_t) -- получение значения по индексам (работает и для
	константных объектов)
	void set(size_t, size_t, double) -- изменение значения по индексам
	
5. Вывод размера матрицы
	size_t num_rows() -- количество строк (работает и для константных объектов)
	size_t num_columns() -- количество строк (работает и для константных объектов)
	
6. Другие перегрузки
	операции сравнения двух матриц (==, !=)
	бинарная операция +, сложение разряженных матриц
	бинарная операция *, умножение * умножение матриц (mult)
	константных объектов)
	операция индексации [i]
	операции для поддержки адресной арифметики 

